[·ÇÖÕ½á·û]
Hao'
Hao
Function
Type
Varlist
Typelist
D
Define
Args
Fbody
Senten
L
S
Left
Right
E
T
F
B
R
Y
IF
[ÖÕ½á·û]
int
double
bool
byte
string
id
var
semic
fn
,
(
)
{
}
=
+
-
*
/
constant
or
and
not
>
<
>=
<=
==
!=
true
false
return
for
if
else
elsif
[ÎÄ·¨ÆðÊ¼·û]
Hao'
[Éú³ÉÊ½]
Hao' => Hao;
Hao => Hao Function;
Hao => Function;

Type => int;
Type => double;
Type => bool;
Type => byte; 
Type => string; 

Varlist => Varlist , id;
Varlist => id;

D => var Define;
Define => Define , Varlist Type;
Define => Varlist Type;

Function => fn id ( Args ) Typelist { Fbody };
Typelist => Type;
Typelist => Typelist , Type;
Args => Args , Varlist Type;
Args => Varlist Type;
Args => ;

Fbody => Senten Fbody;
Fbody => Senten;


Senten => Senten L;
Senten => L semic;

L => D;
L => S;

S => Left = Right; 

Left => Varlist;
Right => E , Right;
Right => E;

E => T;
E => E + T;
E => E - T;
T => F;
T => T * F;
T => T / F;
F => ( E );
F => id;
F => constant;
E => id ( Varlist );

B => R;
B => B or R;
R => Y;
R => R and Y;
Y => ( B );
B => not Y;
B => E < E;
B => E > E;
B => E >= E;
B => E <= E;
B => E == E;
B => E != E;
B => true;
B => false;

S => return E;
S => for E semic B semic E { Fbody };
S => for semic B semic { Fbody };
S => for semic semic { Fbody };
IF => if B { Fbody } else IF;
IF => if B { Fbody };
IF => if B { Fbody } else { Fbody };
S => IF;
