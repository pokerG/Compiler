[非终结符]
Hao'
Hao
Function
Type
Varlist
Typelist
D
Define
Args
Fbody
Senten
L
S
Assign
Left
Right
E
T
F
B
R
Y
IF
[终结符]
int
double
bool
byte
string
id
var
semic
fn
fid
call
,
(
)
{
}
=
+
-
*
/
constant
or
and
not
>
<
>=
<=
==
!=
true
false
return
for
if
else
elsif
[文法起始符]
Hao'
[生成式]
Hao' => Hao;
Hao => Hao Function;
Hao => Function;

Type => int;
Type => double;
Type => bool;
Type => byte; 
Type => string; 

Varlist => Varlist , id;
Varlist => id;

D => var Define;
Define => Define , Varlist Type;
Define => Varlist Type;

Function => fn fid ( Args ) Typelist { Fbody };
Function => fn fid ( Args ) { Fbody };
Typelist => Type;
Typelist => Typelist , Type;
Args => Args , Varlist Type;
Args => Varlist Type;
Args => ;

Fbody => Senten Fbody;
Fbody => Senten;


Senten => Senten L;
Senten => L semic;

L => D;
L => S;


S => Assign;
Assign => Left = Right; 
Left => Varlist;
Right => E , Right;
Right => B , Right;
Right => E;
Right => B;

E => T;
E => E + T;
E => E - T;
T => F;
T => T * F;
T => T / F;
F => ( E );
F => id;
F => constant;
E => fid ( Varlist );


B => R;
B => B or R;
R => Y;
R => R and Y;
Y => ( B );
B => not Y;
B => E < E;
B => E > E;
B => E >= E;
B => E <= E;
B => E == E;
B => E != E;
B => true;
B => false;


S => return E;
S => for Assign semic B semic Assign { Fbody };
S => for semic B semic { Fbody };
S => for semic B semic Assign { Fbody };
S => for Assign semic B semic { Fbody };
S => for semic semic { Fbody };
IF => if B { Fbody } else IF;
IF => if B { Fbody };
IF => if B { Fbody } else { Fbody };
S => IF;